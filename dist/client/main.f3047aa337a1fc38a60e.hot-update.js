webpackHotUpdate("main",{

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst toPropertyKey_js_1 = __importDefault(__webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\"));\r\nfunction _defineProperty(obj, key, value) {\r\n    key = (0, toPropertyKey_js_1.default)(key);\r\n    if (key in obj) {\r\n        Object.defineProperty(obj, key, {\r\n            value: value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        });\r\n    }\r\n    else {\r\n        obj[key] = value;\r\n    }\r\n    return obj;\r\n}\r\nexports.default = _defineProperty;\r\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/defineProperty.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectSpread2.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst defineProperty_js_1 = __importDefault(__webpack_require__(/*! ./defineProperty.js */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\"));\r\nfunction ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n    if (Object.getOwnPropertySymbols) {\r\n        var symbols = Object.getOwnPropertySymbols(object);\r\n        enumerableOnly && (symbols = symbols.filter(function (sym) {\r\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n        })), keys.push.apply(keys, symbols);\r\n    }\r\n    return keys;\r\n}\r\nfunction _objectSpread2(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n        var source = null != arguments[i] ? arguments[i] : {};\r\n        i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\r\n            (0, defineProperty_js_1.default)(target, key, source[key]);\r\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\r\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\r\n        });\r\n    }\r\n    return target;\r\n}\r\nexports.default = _objectSpread2;\r\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/objectSpread2.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeof_js_1 = __importDefault(__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\"));\r\nfunction _toPrimitive(input, hint) {\r\n    if ((0, typeof_js_1.default)(input) !== \"object\" || input === null)\r\n        return input;\r\n    var prim = input[Symbol.toPrimitive];\r\n    if (prim !== undefined) {\r\n        var res = prim.call(input, hint || \"default\");\r\n        if ((0, typeof_js_1.default)(res) !== \"object\")\r\n            return res;\r\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\r\n    }\r\n    return (hint === \"string\" ? String : Number)(input);\r\n}\r\nexports.default = _toPrimitive;\r\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/toPrimitive.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeof_js_1 = __importDefault(__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\"));\r\nconst toPrimitive_js_1 = __importDefault(__webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\"));\r\nfunction _toPropertyKey(arg) {\r\n    var key = (0, toPrimitive_js_1.default)(arg, \"string\");\r\n    return (0, typeof_js_1.default)(key) === \"symbol\" ? key : String(key);\r\n}\r\nexports.default = _toPropertyKey;\r\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction _typeof(obj) {\r\n    \"@babel/helpers - typeof\";\r\n    return exports._typeof = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\r\n        return typeof obj;\r\n    } : function (obj) {\r\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n    }, _typeof(obj);\r\n}\r\nexports.default = _typeof;\r\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/esm/typeof.js?");

/***/ }),

/***/ "./node_modules/redux-devtools-extension/index.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-devtools-extension/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar compose = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\").compose;\r\nexports.__esModule = true;\r\nexports.composeWithDevTools =\r\n    typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n        ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n        : function () {\r\n            if (arguments.length === 0)\r\n                return undefined;\r\n            if (typeof arguments[0] === 'object')\r\n                return compose;\r\n            return compose.apply(null, arguments);\r\n        };\r\nexports.devToolsEnhancer =\r\n    typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__\r\n        ? window.__REDUX_DEVTOOLS_EXTENSION__\r\n        : function () {\r\n            return function (noop) {\r\n                return noop;\r\n            };\r\n        };\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-devtools-extension/index.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/redux-persist/es/constants.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DEFAULT_VERSION = exports.REGISTER = exports.PURGE = exports.PERSIST = exports.PAUSE = exports.REHYDRATE = exports.FLUSH = exports.KEY_PREFIX = void 0;\r\nexports.KEY_PREFIX = 'persist:';\r\nexports.FLUSH = 'persist/FLUSH';\r\nexports.REHYDRATE = 'persist/REHYDRATE';\r\nexports.PAUSE = 'persist/PAUSE';\r\nexports.PERSIST = 'persist/PERSIST';\r\nexports.PURGE = 'persist/PURGE';\r\nexports.REGISTER = 'persist/REGISTER';\r\nexports.DEFAULT_VERSION = -1;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/constants.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/createMigrate.js":
/*!********************************************************!*\
  !*** ./node_modules/redux-persist/es/createMigrate.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\nfunction createMigrate(migrations, config) {\r\n    var _ref = config || {}, debug = _ref.debug;\r\n    return function (state, currentVersion) {\r\n        if (!state) {\r\n            if ( true && debug)\r\n                console.log('redux-persist: no inbound state, skipping migration');\r\n            return Promise.resolve(undefined);\r\n        }\r\n        var inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : constants_1.DEFAULT_VERSION;\r\n        if (inboundVersion === currentVersion) {\r\n            if ( true && debug)\r\n                console.log('redux-persist: versions match, noop migration');\r\n            return Promise.resolve(state);\r\n        }\r\n        if (inboundVersion > currentVersion) {\r\n            if (true)\r\n                console.error('redux-persist: downgrading version is not supported');\r\n            return Promise.resolve(state);\r\n        }\r\n        var migrationKeys = Object.keys(migrations).map(function (ver) {\r\n            return parseInt(ver);\r\n        }).filter(function (key) {\r\n            return currentVersion >= key && key > inboundVersion;\r\n        }).sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n        if ( true && debug)\r\n            console.log('redux-persist: migrationKeys', migrationKeys);\r\n        try {\r\n            var migratedState = migrationKeys.reduce(function (state, versionKey) {\r\n                if ( true && debug)\r\n                    console.log('redux-persist: running migration for versionKey', versionKey);\r\n                return migrations[versionKey](state);\r\n            }, state);\r\n            return Promise.resolve(migratedState);\r\n        }\r\n        catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    };\r\n}\r\nexports.default = createMigrate;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/createMigrate.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/createPersistoid.js":
/*!***********************************************************!*\
  !*** ./node_modules/redux-persist/es/createPersistoid.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\n// @TODO remove once flow < 0.63 support is no longer required.\r\nfunction createPersistoid(config) {\r\n    // defaults\r\n    var blacklist = config.blacklist || null;\r\n    var whitelist = config.whitelist || null;\r\n    var transforms = config.transforms || [];\r\n    var throttle = config.throttle || 0;\r\n    var storageKey = \"\".concat(config.keyPrefix !== undefined ? config.keyPrefix : constants_1.KEY_PREFIX).concat(config.key);\r\n    var storage = config.storage;\r\n    var serialize;\r\n    if (config.serialize === false) {\r\n        serialize = function serialize(x) {\r\n            return x;\r\n        };\r\n    }\r\n    else if (typeof config.serialize === 'function') {\r\n        serialize = config.serialize;\r\n    }\r\n    else {\r\n        serialize = defaultSerialize;\r\n    }\r\n    var writeFailHandler = config.writeFailHandler || null; // initialize stateful values\r\n    var lastState = {};\r\n    var stagedState = {};\r\n    var keysToProcess = [];\r\n    var timeIterator = null;\r\n    var writePromise = null;\r\n    var update = function update(state) {\r\n        // add any changed keys to the queue\r\n        Object.keys(state).forEach(function (key) {\r\n            if (!passWhitelistBlacklist(key))\r\n                return; // is keyspace ignored? noop\r\n            if (lastState[key] === state[key])\r\n                return; // value unchanged? noop\r\n            if (keysToProcess.indexOf(key) !== -1)\r\n                return; // is key already queued? noop\r\n            keysToProcess.push(key); // add key to queue\r\n        }); //if any key is missing in the new state which was present in the lastState,\r\n        //add it for processing too\r\n        Object.keys(lastState).forEach(function (key) {\r\n            if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) {\r\n                keysToProcess.push(key);\r\n            }\r\n        }); // start the time iterator if not running (read: throttle)\r\n        if (timeIterator === null) {\r\n            timeIterator = setInterval(processNextKey, throttle);\r\n        }\r\n        lastState = state;\r\n    };\r\n    function processNextKey() {\r\n        if (keysToProcess.length === 0) {\r\n            if (timeIterator)\r\n                clearInterval(timeIterator);\r\n            timeIterator = null;\r\n            return;\r\n        }\r\n        var key = keysToProcess.shift();\r\n        var endState = transforms.reduce(function (subState, transformer) {\r\n            return transformer.in(subState, key, lastState);\r\n        }, lastState[key]);\r\n        if (endState !== undefined) {\r\n            try {\r\n                stagedState[key] = serialize(endState);\r\n            }\r\n            catch (err) {\r\n                console.error('redux-persist/createPersistoid: error serializing state', err);\r\n            }\r\n        }\r\n        else {\r\n            //if the endState is undefined, no need to persist the existing serialized content\r\n            delete stagedState[key];\r\n        }\r\n        if (keysToProcess.length === 0) {\r\n            writeStagedState();\r\n        }\r\n    }\r\n    function writeStagedState() {\r\n        // cleanup any removed keys just before write.\r\n        Object.keys(stagedState).forEach(function (key) {\r\n            if (lastState[key] === undefined) {\r\n                delete stagedState[key];\r\n            }\r\n        });\r\n        writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);\r\n    }\r\n    function passWhitelistBlacklist(key) {\r\n        if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist')\r\n            return false;\r\n        if (blacklist && blacklist.indexOf(key) !== -1)\r\n            return false;\r\n        return true;\r\n    }\r\n    function onWriteFail(err) {\r\n        // @TODO add fail handlers (typically storage full)\r\n        if (writeFailHandler)\r\n            writeFailHandler(err);\r\n        if (err && \"development\" !== 'production') {\r\n            console.error('Error storing data', err);\r\n        }\r\n    }\r\n    var flush = function flush() {\r\n        while (keysToProcess.length !== 0) {\r\n            processNextKey();\r\n        }\r\n        return writePromise || Promise.resolve();\r\n    }; // return `persistoid`\r\n    return {\r\n        update: update,\r\n        flush: flush\r\n    };\r\n} // @NOTE in the future this may be exposed via config\r\nexports.default = createPersistoid;\r\nfunction defaultSerialize(data) {\r\n    return JSON.stringify(data);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/createPersistoid.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/createTransform.js":
/*!**********************************************************!*\
  !*** ./node_modules/redux-persist/es/createTransform.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createTransform(// @NOTE inbound: transform state coming from redux on its way to being serialized and stored\r\ninbound, // @NOTE outbound: transform state coming from storage, on its way to be rehydrated into redux\r\noutbound) {\r\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var whitelist = config.whitelist || null;\r\n    var blacklist = config.blacklist || null;\r\n    function whitelistBlacklistCheck(key) {\r\n        if (whitelist && whitelist.indexOf(key) === -1)\r\n            return true;\r\n        if (blacklist && blacklist.indexOf(key) !== -1)\r\n            return true;\r\n        return false;\r\n    }\r\n    return {\r\n        in: function _in(state, key, fullState) {\r\n            return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;\r\n        },\r\n        out: function out(state, key, fullState) {\r\n            return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;\r\n        }\r\n    };\r\n}\r\nexports.default = createTransform;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/createTransform.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/getStoredState.js":
/*!*********************************************************!*\
  !*** ./node_modules/redux-persist/es/getStoredState.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\nfunction getStoredState(config) {\r\n    var transforms = config.transforms || [];\r\n    var storageKey = \"\".concat(config.keyPrefix !== undefined ? config.keyPrefix : constants_1.KEY_PREFIX).concat(config.key);\r\n    var storage = config.storage;\r\n    var debug = config.debug;\r\n    var deserialize;\r\n    if (config.deserialize === false) {\r\n        deserialize = function deserialize(x) {\r\n            return x;\r\n        };\r\n    }\r\n    else if (typeof config.deserialize === 'function') {\r\n        deserialize = config.deserialize;\r\n    }\r\n    else {\r\n        deserialize = defaultDeserialize;\r\n    }\r\n    return storage.getItem(storageKey).then(function (serialized) {\r\n        if (!serialized)\r\n            return undefined;\r\n        else {\r\n            try {\r\n                var state = {};\r\n                var rawState = deserialize(serialized);\r\n                Object.keys(rawState).forEach(function (key) {\r\n                    state[key] = transforms.reduceRight(function (subState, transformer) {\r\n                        return transformer.out(subState, key, rawState);\r\n                    }, deserialize(rawState[key]));\r\n                });\r\n                return state;\r\n            }\r\n            catch (err) {\r\n                if ( true && debug)\r\n                    console.log(\"redux-persist/getStoredState: Error restoring data \".concat(serialized), err);\r\n                throw err;\r\n            }\r\n        }\r\n    });\r\n}\r\nexports.default = getStoredState;\r\nfunction defaultDeserialize(serial) {\r\n    return JSON.parse(serial);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/getStoredState.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/index.js":
/*!************************************************!*\
  !*** ./node_modules/redux-persist/es/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.purgeStoredState = exports.createPersistoid = exports.getStoredState = exports.createTransform = exports.createMigrate = exports.persistStore = exports.persistCombineReducers = exports.persistReducer = void 0;\r\nvar persistReducer_1 = __webpack_require__(/*! ./persistReducer */ \"./node_modules/redux-persist/es/persistReducer.js\");\r\nObject.defineProperty(exports, \"persistReducer\", { enumerable: true, get: function () { return __importDefault(persistReducer_1).default; } });\r\nvar persistCombineReducers_1 = __webpack_require__(/*! ./persistCombineReducers */ \"./node_modules/redux-persist/es/persistCombineReducers.js\");\r\nObject.defineProperty(exports, \"persistCombineReducers\", { enumerable: true, get: function () { return __importDefault(persistCombineReducers_1).default; } });\r\nvar persistStore_1 = __webpack_require__(/*! ./persistStore */ \"./node_modules/redux-persist/es/persistStore.js\");\r\nObject.defineProperty(exports, \"persistStore\", { enumerable: true, get: function () { return __importDefault(persistStore_1).default; } });\r\nvar createMigrate_1 = __webpack_require__(/*! ./createMigrate */ \"./node_modules/redux-persist/es/createMigrate.js\");\r\nObject.defineProperty(exports, \"createMigrate\", { enumerable: true, get: function () { return __importDefault(createMigrate_1).default; } });\r\nvar createTransform_1 = __webpack_require__(/*! ./createTransform */ \"./node_modules/redux-persist/es/createTransform.js\");\r\nObject.defineProperty(exports, \"createTransform\", { enumerable: true, get: function () { return __importDefault(createTransform_1).default; } });\r\nvar getStoredState_1 = __webpack_require__(/*! ./getStoredState */ \"./node_modules/redux-persist/es/getStoredState.js\");\r\nObject.defineProperty(exports, \"getStoredState\", { enumerable: true, get: function () { return __importDefault(getStoredState_1).default; } });\r\nvar createPersistoid_1 = __webpack_require__(/*! ./createPersistoid */ \"./node_modules/redux-persist/es/createPersistoid.js\");\r\nObject.defineProperty(exports, \"createPersistoid\", { enumerable: true, get: function () { return __importDefault(createPersistoid_1).default; } });\r\nvar purgeStoredState_1 = __webpack_require__(/*! ./purgeStoredState */ \"./node_modules/redux-persist/es/purgeStoredState.js\");\r\nObject.defineProperty(exports, \"purgeStoredState\", { enumerable: true, get: function () { return __importDefault(purgeStoredState_1).default; } });\r\n__exportStar(__webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/index.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/persistCombineReducers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/redux-persist/es/persistCombineReducers.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst redux_1 = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\");\r\nconst persistReducer_1 = __importDefault(__webpack_require__(/*! ./persistReducer */ \"./node_modules/redux-persist/es/persistReducer.js\"));\r\nconst autoMergeLevel2_1 = __importDefault(__webpack_require__(/*! ./stateReconciler/autoMergeLevel2 */ \"./node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js\"));\r\n// combineReducers + persistReducer with stateReconciler defaulted to autoMergeLevel2\r\nfunction persistCombineReducers(config, reducers) {\r\n    config.stateReconciler = config.stateReconciler === undefined ? autoMergeLevel2_1.default : config.stateReconciler;\r\n    return (0, persistReducer_1.default)(config, (0, redux_1.combineReducers)(reducers));\r\n}\r\nexports.default = persistCombineReducers;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/persistCombineReducers.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/persistReducer.js":
/*!*********************************************************!*\
  !*** ./node_modules/redux-persist/es/persistReducer.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly)\r\n        symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });\r\n    keys.push.apply(keys, symbols);\r\n} return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n    if (i % 2) {\r\n        ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); });\r\n    }\r\n    else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    }\r\n    else {\r\n        ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });\r\n    }\r\n} return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n}\r\nelse {\r\n    obj[key] = value;\r\n} return obj; }\r\nfunction _objectWithoutProperties(source, excluded) { if (source == null)\r\n    return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) {\r\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\r\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\r\n        key = sourceSymbolKeys[i];\r\n        if (excluded.indexOf(key) >= 0)\r\n            continue;\r\n        if (!Object.prototype.propertyIsEnumerable.call(source, key))\r\n            continue;\r\n        target[key] = source[key];\r\n    }\r\n} return target; }\r\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null)\r\n    return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0)\r\n        continue;\r\n    target[key] = source[key];\r\n} return target; }\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\nconst autoMergeLevel1_1 = __importDefault(__webpack_require__(/*! ./stateReconciler/autoMergeLevel1 */ \"./node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js\"));\r\nconst createPersistoid_1 = __importDefault(__webpack_require__(/*! ./createPersistoid */ \"./node_modules/redux-persist/es/createPersistoid.js\"));\r\nconst getStoredState_1 = __importDefault(__webpack_require__(/*! ./getStoredState */ \"./node_modules/redux-persist/es/getStoredState.js\"));\r\nconst purgeStoredState_1 = __importDefault(__webpack_require__(/*! ./purgeStoredState */ \"./node_modules/redux-persist/es/purgeStoredState.js\"));\r\nvar DEFAULT_TIMEOUT = 5000;\r\n/*\r\n  @TODO add validation / handling for:\r\n  - persisting a reducer which has nested _persist\r\n  - handling actions that fire before reydrate is called\r\n*/\r\nfunction persistReducer(config, baseReducer) {\r\n    if (true) {\r\n        if (!config)\r\n            throw new Error('config is required for persistReducer');\r\n        if (!config.key)\r\n            throw new Error('key is required in persistor config');\r\n        if (!config.storage)\r\n            throw new Error(\"redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`\");\r\n    }\r\n    var version = config.version !== undefined ? config.version : constants_1.DEFAULT_VERSION;\r\n    var debug = config.debug || false;\r\n    var stateReconciler = config.stateReconciler === undefined ? autoMergeLevel1_1.default : config.stateReconciler;\r\n    var getStoredState = config.getStoredState || getStoredState_1.default;\r\n    var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;\r\n    var _persistoid = null;\r\n    var _purge = false;\r\n    var _paused = true;\r\n    var conditionalUpdate = function conditionalUpdate(state) {\r\n        // update the persistoid only if we are rehydrated and not paused\r\n        state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);\r\n        return state;\r\n    };\r\n    return function (state, action) {\r\n        var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, [\"_persist\"]); // $FlowIgnore need to update State type\r\n        var restState = rest;\r\n        if (action.type === constants_1.PERSIST) {\r\n            var _sealed = false;\r\n            var _rehydrate = function _rehydrate(payload, err) {\r\n                // dev warning if we are already sealed\r\n                if ( true && _sealed)\r\n                    console.error(\"redux-persist: rehydrate for \\\"\".concat(config.key, \"\\\" called after timeout.\"), payload, err); // only rehydrate if we are not already sealed\r\n                if (!_sealed) {\r\n                    action.rehydrate(config.key, payload, err);\r\n                    _sealed = true;\r\n                }\r\n            };\r\n            timeout && setTimeout(function () {\r\n                !_sealed && _rehydrate(undefined, new Error(\"redux-persist: persist timed out for persist key \\\"\".concat(config.key, \"\\\"\")));\r\n            }, timeout); // @NOTE PERSIST resumes if paused.\r\n            _paused = false; // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set\r\n            if (!_persistoid)\r\n                _persistoid = (0, createPersistoid_1.default)(config); // @NOTE PERSIST can be called multiple times, noop after the first\r\n            if (_persist) {\r\n                // We still need to call the base reducer because there might be nested\r\n                // uses of persistReducer which need to be aware of the PERSIST action\r\n                return _objectSpread({}, baseReducer(restState, action), {\r\n                    _persist: _persist\r\n                });\r\n            }\r\n            if (typeof action.rehydrate !== 'function' || typeof action.register !== 'function')\r\n                throw new Error('redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.');\r\n            action.register(config.key);\r\n            getStoredState(config).then(function (restoredState) {\r\n                var migrate = config.migrate || function (s, v) {\r\n                    return Promise.resolve(s);\r\n                };\r\n                migrate(restoredState, version).then(function (migratedState) {\r\n                    _rehydrate(migratedState);\r\n                }, function (migrateErr) {\r\n                    if ( true && migrateErr)\r\n                        console.error('redux-persist: migration error', migrateErr);\r\n                    _rehydrate(undefined, migrateErr);\r\n                });\r\n            }, function (err) {\r\n                _rehydrate(undefined, err);\r\n            });\r\n            return _objectSpread({}, baseReducer(restState, action), {\r\n                _persist: {\r\n                    version: version,\r\n                    rehydrated: false\r\n                }\r\n            });\r\n        }\r\n        else if (action.type === constants_1.PURGE) {\r\n            _purge = true;\r\n            action.result((0, purgeStoredState_1.default)(config));\r\n            return _objectSpread({}, baseReducer(restState, action), {\r\n                _persist: _persist\r\n            });\r\n        }\r\n        else if (action.type === constants_1.FLUSH) {\r\n            action.result(_persistoid && _persistoid.flush());\r\n            return _objectSpread({}, baseReducer(restState, action), {\r\n                _persist: _persist\r\n            });\r\n        }\r\n        else if (action.type === constants_1.PAUSE) {\r\n            _paused = true;\r\n        }\r\n        else if (action.type === constants_1.REHYDRATE) {\r\n            // noop on restState if purging\r\n            if (_purge)\r\n                return _objectSpread({}, restState, {\r\n                    _persist: _objectSpread({}, _persist, {\r\n                        rehydrated: true\r\n                    }) // @NOTE if key does not match, will continue to default else below\r\n                });\r\n            if (action.key === config.key) {\r\n                var reducedState = baseReducer(restState, action);\r\n                var inboundState = action.payload; // only reconcile state if stateReconciler and inboundState are both defined\r\n                var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;\r\n                var _newState = _objectSpread({}, reconciledRest, {\r\n                    _persist: _objectSpread({}, _persist, {\r\n                        rehydrated: true\r\n                    })\r\n                });\r\n                return conditionalUpdate(_newState);\r\n            }\r\n        } // if we have not already handled PERSIST, straight passthrough\r\n        if (!_persist)\r\n            return baseReducer(state, action); // run base reducer:\r\n        // is state modified ? return original : return updated\r\n        var newState = baseReducer(restState, action);\r\n        if (newState === restState)\r\n            return state;\r\n        return conditionalUpdate(_objectSpread({}, newState, {\r\n            _persist: _persist\r\n        }));\r\n    };\r\n}\r\nexports.default = persistReducer;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/persistReducer.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/persistStore.js":
/*!*******************************************************!*\
  !*** ./node_modules/redux-persist/es/persistStore.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\r\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\r\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\")\r\n    return Array.from(iter); }\r\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) {\r\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\r\n        arr2[i] = arr[i];\r\n    }\r\n    return arr2;\r\n} }\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly)\r\n        symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });\r\n    keys.push.apply(keys, symbols);\r\n} return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n    if (i % 2) {\r\n        ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); });\r\n    }\r\n    else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    }\r\n    else {\r\n        ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });\r\n    }\r\n} return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n}\r\nelse {\r\n    obj[key] = value;\r\n} return obj; }\r\nconst redux_1 = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\nvar initialState = {\r\n    registry: [],\r\n    bootstrapped: false\r\n};\r\nvar persistorReducer = function persistorReducer() {\r\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\r\n    var action = arguments.length > 1 ? arguments[1] : undefined;\r\n    switch (action.type) {\r\n        case constants_1.REGISTER:\r\n            return _objectSpread({}, state, {\r\n                registry: [].concat(_toConsumableArray(state.registry), [action.key])\r\n            });\r\n        case constants_1.REHYDRATE:\r\n            var firstIndex = state.registry.indexOf(action.key);\r\n            var registry = _toConsumableArray(state.registry);\r\n            registry.splice(firstIndex, 1);\r\n            return _objectSpread({}, state, {\r\n                registry: registry,\r\n                bootstrapped: registry.length === 0\r\n            });\r\n        default:\r\n            return state;\r\n    }\r\n};\r\nfunction persistStore(store, options, cb) {\r\n    // help catch incorrect usage of passing PersistConfig in as PersistorOptions\r\n    if (true) {\r\n        var optionsToTest = options || {};\r\n        var bannedKeys = ['blacklist', 'whitelist', 'transforms', 'storage', 'keyPrefix', 'migrate'];\r\n        bannedKeys.forEach(function (k) {\r\n            if (!!optionsToTest[k])\r\n                console.error(\"redux-persist: invalid option passed to persistStore: \\\"\".concat(k, \"\\\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.\"));\r\n        });\r\n    }\r\n    var boostrappedCb = cb || false;\r\n    var _pStore = (0, redux_1.createStore)(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);\r\n    var register = function register(key) {\r\n        _pStore.dispatch({\r\n            type: constants_1.REGISTER,\r\n            key: key\r\n        });\r\n    };\r\n    var rehydrate = function rehydrate(key, payload, err) {\r\n        var rehydrateAction = {\r\n            type: constants_1.REHYDRATE,\r\n            payload: payload,\r\n            err: err,\r\n            key: key // dispatch to `store` to rehydrate and `persistor` to track result\r\n        };\r\n        store.dispatch(rehydrateAction);\r\n        _pStore.dispatch(rehydrateAction);\r\n        if (boostrappedCb && persistor.getState().bootstrapped) {\r\n            boostrappedCb();\r\n            boostrappedCb = false;\r\n        }\r\n    };\r\n    var persistor = _objectSpread({}, _pStore, {\r\n        purge: function purge() {\r\n            var results = [];\r\n            store.dispatch({\r\n                type: constants_1.PURGE,\r\n                result: function result(purgeResult) {\r\n                    results.push(purgeResult);\r\n                }\r\n            });\r\n            return Promise.all(results);\r\n        },\r\n        flush: function flush() {\r\n            var results = [];\r\n            store.dispatch({\r\n                type: constants_1.FLUSH,\r\n                result: function result(flushResult) {\r\n                    results.push(flushResult);\r\n                }\r\n            });\r\n            return Promise.all(results);\r\n        },\r\n        pause: function pause() {\r\n            store.dispatch({\r\n                type: constants_1.PAUSE\r\n            });\r\n        },\r\n        persist: function persist() {\r\n            store.dispatch({\r\n                type: constants_1.PERSIST,\r\n                register: register,\r\n                rehydrate: rehydrate\r\n            });\r\n        }\r\n    });\r\n    if (!(options && options.manualPersist)) {\r\n        persistor.persist();\r\n    }\r\n    return persistor;\r\n}\r\nexports.default = persistStore;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/persistStore.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/purgeStoredState.js":
/*!***********************************************************!*\
  !*** ./node_modules/redux-persist/es/purgeStoredState.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/redux-persist/es/constants.js\");\r\nfunction purgeStoredState(config) {\r\n    var storage = config.storage;\r\n    var storageKey = \"\".concat(config.keyPrefix !== undefined ? config.keyPrefix : constants_1.KEY_PREFIX).concat(config.key);\r\n    return storage.removeItem(storageKey, warnIfRemoveError);\r\n}\r\nexports.default = purgeStoredState;\r\nfunction warnIfRemoveError(err) {\r\n    if (err && \"development\" !== 'production') {\r\n        console.error('redux-persist/purgeStoredState: Error purging data stored state', err);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/purgeStoredState.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n    _typeof = function _typeof(obj) { return typeof obj; };\r\n}\r\nelse {\r\n    _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n} return _typeof(obj); }\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly)\r\n        symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });\r\n    keys.push.apply(keys, symbols);\r\n} return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n    if (i % 2) {\r\n        ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); });\r\n    }\r\n    else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    }\r\n    else {\r\n        ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });\r\n    }\r\n} return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n}\r\nelse {\r\n    obj[key] = value;\r\n} return obj; }\r\n/*\r\n  autoMergeLevel1:\r\n    - merges 1 level of substate\r\n    - skips substate if already modified\r\n*/\r\nfunction autoMergeLevel1(inboundState, originalState, reducedState, _ref) {\r\n    var debug = _ref.debug;\r\n    var newState = _objectSpread({}, reducedState); // only rehydrate if inboundState exists and is an object\r\n    if (inboundState && _typeof(inboundState) === 'object') {\r\n        Object.keys(inboundState).forEach(function (key) {\r\n            // ignore _persist data\r\n            if (key === '_persist')\r\n                return; // if reducer modifies substate, skip auto rehydration\r\n            if (originalState[key] !== reducedState[key]) {\r\n                if ( true && debug)\r\n                    console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\r\n                return;\r\n            } // otherwise hard set the new value\r\n            newState[key] = inboundState[key];\r\n        });\r\n    }\r\n    if ( true && debug && inboundState && _typeof(inboundState) === 'object')\r\n        console.log(\"redux-persist/stateReconciler: rehydrated keys '\".concat(Object.keys(inboundState).join(', '), \"'\"));\r\n    return newState;\r\n}\r\nexports.default = autoMergeLevel1;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js?");

/***/ }),

/***/ "./node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js":
/*!**************************************************************************!*\
  !*** ./node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n    _typeof = function _typeof(obj) { return typeof obj; };\r\n}\r\nelse {\r\n    _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n} return _typeof(obj); }\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly)\r\n        symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });\r\n    keys.push.apply(keys, symbols);\r\n} return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n    if (i % 2) {\r\n        ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); });\r\n    }\r\n    else if (Object.getOwnPropertyDescriptors) {\r\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    }\r\n    else {\r\n        ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });\r\n    }\r\n} return target; }\r\nfunction _defineProperty(obj, key, value) { if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n}\r\nelse {\r\n    obj[key] = value;\r\n} return obj; }\r\n/*\r\n  autoMergeLevel2:\r\n    - merges 2 level of substate\r\n    - skips substate if already modified\r\n    - this is essentially redux-perist v4 behavior\r\n*/\r\nfunction autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\r\n    var debug = _ref.debug;\r\n    var newState = _objectSpread({}, reducedState); // only rehydrate if inboundState exists and is an object\r\n    if (inboundState && _typeof(inboundState) === 'object') {\r\n        Object.keys(inboundState).forEach(function (key) {\r\n            // ignore _persist data\r\n            if (key === '_persist')\r\n                return; // if reducer modifies substate, skip auto rehydration\r\n            if (originalState[key] !== reducedState[key]) {\r\n                if ( true && debug)\r\n                    console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\r\n                return;\r\n            }\r\n            if (isPlainEnoughObject(reducedState[key])) {\r\n                // if object is plain enough shallow merge the new values (hence \"Level2\")\r\n                newState[key] = _objectSpread({}, newState[key], {}, inboundState[key]);\r\n                return;\r\n            } // otherwise hard set\r\n            newState[key] = inboundState[key];\r\n        });\r\n    }\r\n    if ( true && debug && inboundState && _typeof(inboundState) === 'object')\r\n        console.log(\"redux-persist/stateReconciler: rehydrated keys '\".concat(Object.keys(inboundState).join(', '), \"'\"));\r\n    return newState;\r\n}\r\nexports.default = autoMergeLevel2;\r\nfunction isPlainEnoughObject(o) {\r\n    return o !== null && !Array.isArray(o) && _typeof(o) === 'object';\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/es/stateReconciler/autoMergeLevel2.js?");

/***/ }),

/***/ "./node_modules/redux-persist/lib/storage/createWebStorage.js":
/*!********************************************************************!*\
  !*** ./node_modules/redux-persist/lib/storage/createWebStorage.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.default = createWebStorage;\r\nvar _getStorage = _interopRequireDefault(__webpack_require__(/*! ./getStorage */ \"./node_modules/redux-persist/lib/storage/getStorage.js\"));\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\nfunction createWebStorage(type) {\r\n    var storage = (0, _getStorage.default)(type);\r\n    return {\r\n        getItem: function getItem(key) {\r\n            return new Promise(function (resolve, reject) {\r\n                resolve(storage.getItem(key));\r\n            });\r\n        },\r\n        setItem: function setItem(key, item) {\r\n            return new Promise(function (resolve, reject) {\r\n                resolve(storage.setItem(key, item));\r\n            });\r\n        },\r\n        removeItem: function removeItem(key) {\r\n            return new Promise(function (resolve, reject) {\r\n                resolve(storage.removeItem(key));\r\n            });\r\n        }\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/lib/storage/createWebStorage.js?");

/***/ }),

/***/ "./node_modules/redux-persist/lib/storage/getStorage.js":
/*!**************************************************************!*\
  !*** ./node_modules/redux-persist/lib/storage/getStorage.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.default = getStorage;\r\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n    _typeof = function _typeof(obj) { return typeof obj; };\r\n}\r\nelse {\r\n    _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n} return _typeof(obj); }\r\nfunction noop() { }\r\nvar noopStorage = {\r\n    getItem: noop,\r\n    setItem: noop,\r\n    removeItem: noop\r\n};\r\nfunction hasStorage(storageType) {\r\n    if ((typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) !== 'object' || !(storageType in self)) {\r\n        return false;\r\n    }\r\n    try {\r\n        var storage = self[storageType];\r\n        var testKey = \"redux-persist \".concat(storageType, \" test\");\r\n        storage.setItem(testKey, 'test');\r\n        storage.getItem(testKey);\r\n        storage.removeItem(testKey);\r\n    }\r\n    catch (e) {\r\n        if (true)\r\n            console.warn(\"redux-persist \".concat(storageType, \" test failed, persistence will be disabled.\"));\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction getStorage(type) {\r\n    var storageType = \"\".concat(type, \"Storage\");\r\n    if (hasStorage(storageType))\r\n        return self[storageType];\r\n    else {\r\n        if (true) {\r\n            console.error(\"redux-persist failed to create sync storage. falling back to noop storage.\");\r\n        }\r\n        return noopStorage;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/lib/storage/getStorage.js?");

/***/ }),

/***/ "./node_modules/redux-persist/lib/storage/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/redux-persist/lib/storage/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nexports.__esModule = true;\r\nexports.default = void 0;\r\nvar _createWebStorage = _interopRequireDefault(__webpack_require__(/*! ./createWebStorage */ \"./node_modules/redux-persist/lib/storage/createWebStorage.js\"));\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\nvar _default = (0, _createWebStorage.default)('local');\r\nexports.default = _default;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-persist/lib/storage/index.js?");

/***/ }),

/***/ "./node_modules/redux-thunk/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/redux-thunk/es/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */\r\nfunction createThunkMiddleware(extraArgument) {\r\n    // Standard Redux middleware definition pattern:\r\n    // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\r\n    var middleware = function middleware(_ref) {\r\n        var dispatch = _ref.dispatch, getState = _ref.getState;\r\n        return function (next) {\r\n            return function (action) {\r\n                // The thunk middleware looks for any functions that were passed to `store.dispatch`.\r\n                // If this \"action\" is really a function, call it and return the result.\r\n                if (typeof action === 'function') {\r\n                    // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\r\n                    return action(dispatch, getState, extraArgument);\r\n                } // Otherwise, pass the action down the middleware chain as usual\r\n                return next(action);\r\n            };\r\n        };\r\n    };\r\n    return middleware;\r\n}\r\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\r\n// with whatever \"extra arg\" they want to inject into their thunks\r\nthunk.withExtraArgument = createThunkMiddleware;\r\nexports.default = thunk;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux-thunk/es/index.js?");

/***/ }),

/***/ "./node_modules/redux/es/redux.js":
/*!****************************************!*\
  !*** ./node_modules/redux/es/redux.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.legacy_createStore = exports.createStore = exports.compose = exports.combineReducers = exports.bindActionCreators = exports.applyMiddleware = exports.__DO_NOT_USE__ActionTypes = void 0;\r\nconst objectSpread2_1 = __importDefault(__webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\"));\r\n/**\r\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\r\n *\r\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\r\n * during build.\r\n * @param {number} code\r\n */\r\nfunction formatProdErrorMessage(code) {\r\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\r\n}\r\n// Inlined version of the `symbol-observable` polyfill\r\nvar $$observable = (function () {\r\n    return typeof Symbol === 'function' && Symbol.observable || '@@observable';\r\n})();\r\n/**\r\n * These are private action types reserved by Redux.\r\n * For any unknown actions, you must return the current state.\r\n * If the current state is undefined, you must return the initial state.\r\n * Do not reference these action types directly in your code.\r\n */\r\nvar randomString = function randomString() {\r\n    return Math.random().toString(36).substring(7).split('').join('.');\r\n};\r\nvar ActionTypes = {\r\n    INIT: \"@@redux/INIT\" + randomString(),\r\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\r\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\r\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\r\n    }\r\n};\r\nexports.__DO_NOT_USE__ActionTypes = ActionTypes;\r\n/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\r\nfunction isPlainObject(obj) {\r\n    if (typeof obj !== 'object' || obj === null)\r\n        return false;\r\n    var proto = obj;\r\n    while (Object.getPrototypeOf(proto) !== null) {\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return Object.getPrototypeOf(obj) === proto;\r\n}\r\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\r\nfunction miniKindOf(val) {\r\n    if (val === void 0)\r\n        return 'undefined';\r\n    if (val === null)\r\n        return 'null';\r\n    var type = typeof val;\r\n    switch (type) {\r\n        case 'boolean':\r\n        case 'string':\r\n        case 'number':\r\n        case 'symbol':\r\n        case 'function':\r\n            {\r\n                return type;\r\n            }\r\n    }\r\n    if (Array.isArray(val))\r\n        return 'array';\r\n    if (isDate(val))\r\n        return 'date';\r\n    if (isError(val))\r\n        return 'error';\r\n    var constructorName = ctorName(val);\r\n    switch (constructorName) {\r\n        case 'Symbol':\r\n        case 'Promise':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n        case 'Map':\r\n        case 'Set':\r\n            return constructorName;\r\n    } // other\r\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\r\n}\r\nfunction ctorName(val) {\r\n    return typeof val.constructor === 'function' ? val.constructor.name : null;\r\n}\r\nfunction isError(val) {\r\n    return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\r\n}\r\nfunction isDate(val) {\r\n    if (val instanceof Date)\r\n        return true;\r\n    return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\r\n}\r\nfunction kindOf(val) {\r\n    var typeOfVal = typeof val;\r\n    if (true) {\r\n        typeOfVal = miniKindOf(val);\r\n    }\r\n    return typeOfVal;\r\n}\r\n/**\r\n * @deprecated\r\n *\r\n * **We recommend using the `configureStore` method\r\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\r\n *\r\n * Redux Toolkit is our recommended approach for writing Redux logic today,\r\n * including store setup, reducers, data fetching, and more.\r\n *\r\n * **For more details, please read this Redux docs page:**\r\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\r\n *\r\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\r\n * simplifies setup and helps avoid common bugs.\r\n *\r\n * You should not be using the `redux` core package by itself today, except for learning purposes.\r\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\r\n * all users to migrate to using Redux Toolkit for all Redux code.\r\n *\r\n * If you want to use `createStore` without this visual deprecation warning, use\r\n * the `legacy_createStore` import instead:\r\n *\r\n * `import { legacy_createStore as createStore} from 'redux'`\r\n *\r\n */\r\nfunction createStore(reducer, preloadedState, enhancer) {\r\n    var _ref2;\r\n    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\r\n        throw new Error( false ? undefined : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\r\n    }\r\n    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n        enhancer = preloadedState;\r\n        preloadedState = undefined;\r\n    }\r\n    if (typeof enhancer !== 'undefined') {\r\n        if (typeof enhancer !== 'function') {\r\n            throw new Error( false ? undefined : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\r\n        }\r\n        return enhancer(createStore)(reducer, preloadedState);\r\n    }\r\n    if (typeof reducer !== 'function') {\r\n        throw new Error( false ? undefined : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\r\n    }\r\n    var currentReducer = reducer;\r\n    var currentState = preloadedState;\r\n    var currentListeners = [];\r\n    var nextListeners = currentListeners;\r\n    var isDispatching = false;\r\n    /**\r\n     * This makes a shallow copy of currentListeners so we can use\r\n     * nextListeners as a temporary list while dispatching.\r\n     *\r\n     * This prevents any bugs around consumers calling\r\n     * subscribe/unsubscribe in the middle of a dispatch.\r\n     */\r\n    function ensureCanMutateNextListeners() {\r\n        if (nextListeners === currentListeners) {\r\n            nextListeners = currentListeners.slice();\r\n        }\r\n    }\r\n    /**\r\n     * Reads the state tree managed by the store.\r\n     *\r\n     * @returns {any} The current state tree of your application.\r\n     */\r\n    function getState() {\r\n        if (isDispatching) {\r\n            throw new Error( false ? undefined : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\r\n        }\r\n        return currentState;\r\n    }\r\n    /**\r\n     * Adds a change listener. It will be called any time an action is dispatched,\r\n     * and some part of the state tree may potentially have changed. You may then\r\n     * call `getState()` to read the current state tree inside the callback.\r\n     *\r\n     * You may call `dispatch()` from a change listener, with the following\r\n     * caveats:\r\n     *\r\n     * 1. The subscriptions are snapshotted just before every `dispatch()` call.\r\n     * If you subscribe or unsubscribe while the listeners are being invoked, this\r\n     * will not have any effect on the `dispatch()` that is currently in progress.\r\n     * However, the next `dispatch()` call, whether nested or not, will use a more\r\n     * recent snapshot of the subscription list.\r\n     *\r\n     * 2. The listener should not expect to see all state changes, as the state\r\n     * might have been updated multiple times during a nested `dispatch()` before\r\n     * the listener is called. It is, however, guaranteed that all subscribers\r\n     * registered before the `dispatch()` started will be called with the latest\r\n     * state by the time it exits.\r\n     *\r\n     * @param {Function} listener A callback to be invoked on every dispatch.\r\n     * @returns {Function} A function to remove this change listener.\r\n     */\r\n    function subscribe(listener) {\r\n        if (typeof listener !== 'function') {\r\n            throw new Error( false ? undefined : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error( false ? undefined : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\r\n        }\r\n        var isSubscribed = true;\r\n        ensureCanMutateNextListeners();\r\n        nextListeners.push(listener);\r\n        return function unsubscribe() {\r\n            if (!isSubscribed) {\r\n                return;\r\n            }\r\n            if (isDispatching) {\r\n                throw new Error( false ? undefined : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\r\n            }\r\n            isSubscribed = false;\r\n            ensureCanMutateNextListeners();\r\n            var index = nextListeners.indexOf(listener);\r\n            nextListeners.splice(index, 1);\r\n            currentListeners = null;\r\n        };\r\n    }\r\n    /**\r\n     * Dispatches an action. It is the only way to trigger a state change.\r\n     *\r\n     * The `reducer` function, used to create the store, will be called with the\r\n     * current state tree and the given `action`. Its return value will\r\n     * be considered the **next** state of the tree, and the change listeners\r\n     * will be notified.\r\n     *\r\n     * The base implementation only supports plain object actions. If you want to\r\n     * dispatch a Promise, an Observable, a thunk, or something else, you need to\r\n     * wrap your store creating function into the corresponding middleware. For\r\n     * example, see the documentation for the `redux-thunk` package. Even the\r\n     * middleware will eventually dispatch plain object actions using this method.\r\n     *\r\n     * @param {Object} action A plain object representing “what changed”. It is\r\n     * a good idea to keep actions serializable so you can record and replay user\r\n     * sessions, or use the time travelling `redux-devtools`. An action must have\r\n     * a `type` property which may not be `undefined`. It is a good idea to use\r\n     * string constants for action types.\r\n     *\r\n     * @returns {Object} For convenience, the same action object you dispatched.\r\n     *\r\n     * Note that, if you use a custom middleware, it may wrap `dispatch()` to\r\n     * return something else (for example, a Promise you can await).\r\n     */\r\n    function dispatch(action) {\r\n        if (!isPlainObject(action)) {\r\n            throw new Error( false ? undefined : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\r\n        }\r\n        if (typeof action.type === 'undefined') {\r\n            throw new Error( false ? undefined : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error( false ? undefined : 'Reducers may not dispatch actions.');\r\n        }\r\n        try {\r\n            isDispatching = true;\r\n            currentState = currentReducer(currentState, action);\r\n        }\r\n        finally {\r\n            isDispatching = false;\r\n        }\r\n        var listeners = currentListeners = nextListeners;\r\n        for (var i = 0; i < listeners.length; i++) {\r\n            var listener = listeners[i];\r\n            listener();\r\n        }\r\n        return action;\r\n    }\r\n    /**\r\n     * Replaces the reducer currently used by the store to calculate the state.\r\n     *\r\n     * You might need this if your app implements code splitting and you want to\r\n     * load some of the reducers dynamically. You might also need this if you\r\n     * implement a hot reloading mechanism for Redux.\r\n     *\r\n     * @param {Function} nextReducer The reducer for the store to use instead.\r\n     * @returns {void}\r\n     */\r\n    function replaceReducer(nextReducer) {\r\n        if (typeof nextReducer !== 'function') {\r\n            throw new Error( false ? undefined : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\r\n        }\r\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\r\n        // Any reducers that existed in both the new and old rootReducer\r\n        // will receive the previous state. This effectively populates\r\n        // the new state tree with any relevant data from the old one.\r\n        dispatch({\r\n            type: ActionTypes.REPLACE\r\n        });\r\n    }\r\n    /**\r\n     * Interoperability point for observable/reactive libraries.\r\n     * @returns {observable} A minimal observable of state changes.\r\n     * For more information, see the observable proposal:\r\n     * https://github.com/tc39/proposal-observable\r\n     */\r\n    function observable() {\r\n        var _ref;\r\n        var outerSubscribe = subscribe;\r\n        return _ref = {\r\n            /**\r\n             * The minimal observable subscription method.\r\n             * @param {Object} observer Any object that can be used as an observer.\r\n             * The observer object should have a `next` method.\r\n             * @returns {subscription} An object with an `unsubscribe` method that can\r\n             * be used to unsubscribe the observable from the store, and prevent further\r\n             * emission of values from the observable.\r\n             */\r\n            subscribe: function subscribe(observer) {\r\n                if (typeof observer !== 'object' || observer === null) {\r\n                    throw new Error( false ? undefined : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\r\n                }\r\n                function observeState() {\r\n                    if (observer.next) {\r\n                        observer.next(getState());\r\n                    }\r\n                }\r\n                observeState();\r\n                var unsubscribe = outerSubscribe(observeState);\r\n                return {\r\n                    unsubscribe: unsubscribe\r\n                };\r\n            }\r\n        }, _ref[$$observable] = function () {\r\n            return this;\r\n        }, _ref;\r\n    } // When a store is created, an \"INIT\" action is dispatched so that every\r\n    // reducer returns their initial state. This effectively populates\r\n    // the initial state tree.\r\n    dispatch({\r\n        type: ActionTypes.INIT\r\n    });\r\n    return _ref2 = {\r\n        dispatch: dispatch,\r\n        subscribe: subscribe,\r\n        getState: getState,\r\n        replaceReducer: replaceReducer\r\n    }, _ref2[$$observable] = observable, _ref2;\r\n}\r\nexports.createStore = createStore;\r\n/**\r\n * Creates a Redux store that holds the state tree.\r\n *\r\n * **We recommend using `configureStore` from the\r\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\r\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\r\n *\r\n * The only way to change the data in the store is to call `dispatch()` on it.\r\n *\r\n * There should only be a single store in your app. To specify how different\r\n * parts of the state tree respond to actions, you may combine several reducers\r\n * into a single reducer function by using `combineReducers`.\r\n *\r\n * @param {Function} reducer A function that returns the next state tree, given\r\n * the current state tree and the action to handle.\r\n *\r\n * @param {any} [preloadedState] The initial state. You may optionally specify it\r\n * to hydrate the state from the server in universal apps, or to restore a\r\n * previously serialized user session.\r\n * If you use `combineReducers` to produce the root reducer function, this must be\r\n * an object with the same shape as `combineReducers` keys.\r\n *\r\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\r\n * to enhance the store with third-party capabilities such as middleware,\r\n * time travel, persistence, etc. The only store enhancer that ships with Redux\r\n * is `applyMiddleware()`.\r\n *\r\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\r\n * and subscribe to changes.\r\n */\r\nvar legacy_createStore = createStore;\r\nexports.legacy_createStore = legacy_createStore;\r\n/**\r\n * Prints a warning in the console if it exists.\r\n *\r\n * @param {String} message The warning message.\r\n * @returns {void}\r\n */\r\nfunction warning(message) {\r\n    /* eslint-disable no-console */\r\n    if (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n        console.error(message);\r\n    }\r\n    /* eslint-enable no-console */\r\n    try {\r\n        // This error was thrown as a convenience so that if you enable\r\n        // \"break on all exceptions\" in your console,\r\n        // it would pause the execution at this line.\r\n        throw new Error(message);\r\n    }\r\n    catch (e) { } // eslint-disable-line no-empty\r\n}\r\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\r\n    var reducerKeys = Object.keys(reducers);\r\n    var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\r\n    if (reducerKeys.length === 0) {\r\n        return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\r\n    }\r\n    if (!isPlainObject(inputState)) {\r\n        return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\r\n    }\r\n    var unexpectedKeys = Object.keys(inputState).filter(function (key) {\r\n        return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\r\n    });\r\n    unexpectedKeys.forEach(function (key) {\r\n        unexpectedKeyCache[key] = true;\r\n    });\r\n    if (action && action.type === ActionTypes.REPLACE)\r\n        return;\r\n    if (unexpectedKeys.length > 0) {\r\n        return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\r\n    }\r\n}\r\nfunction assertReducerShape(reducers) {\r\n    Object.keys(reducers).forEach(function (key) {\r\n        var reducer = reducers[key];\r\n        var initialState = reducer(undefined, {\r\n            type: ActionTypes.INIT\r\n        });\r\n        if (typeof initialState === 'undefined') {\r\n            throw new Error( false ? undefined : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\r\n        }\r\n        if (typeof reducer(undefined, {\r\n            type: ActionTypes.PROBE_UNKNOWN_ACTION()\r\n        }) === 'undefined') {\r\n            throw new Error( false ? undefined : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle '\" + ActionTypes.INIT + \"' or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\r\n        }\r\n    });\r\n}\r\n/**\r\n * Turns an object whose values are different reducer functions, into a single\r\n * reducer function. It will call every child reducer, and gather their results\r\n * into a single state object, whose keys correspond to the keys of the passed\r\n * reducer functions.\r\n *\r\n * @param {Object} reducers An object whose values correspond to different\r\n * reducer functions that need to be combined into one. One handy way to obtain\r\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\r\n * undefined for any action. Instead, they should return their initial state\r\n * if the state passed to them was undefined, and the current state for any\r\n * unrecognized action.\r\n *\r\n * @returns {Function} A reducer function that invokes every reducer inside the\r\n * passed object, and builds a state object with the same shape.\r\n */\r\nfunction combineReducers(reducers) {\r\n    var reducerKeys = Object.keys(reducers);\r\n    var finalReducers = {};\r\n    for (var i = 0; i < reducerKeys.length; i++) {\r\n        var key = reducerKeys[i];\r\n        if (true) {\r\n            if (typeof reducers[key] === 'undefined') {\r\n                warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\r\n            }\r\n        }\r\n        if (typeof reducers[key] === 'function') {\r\n            finalReducers[key] = reducers[key];\r\n        }\r\n    }\r\n    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\r\n    // keys multiple times.\r\n    var unexpectedKeyCache;\r\n    if (true) {\r\n        unexpectedKeyCache = {};\r\n    }\r\n    var shapeAssertionError;\r\n    try {\r\n        assertReducerShape(finalReducers);\r\n    }\r\n    catch (e) {\r\n        shapeAssertionError = e;\r\n    }\r\n    return function combination(state, action) {\r\n        if (state === void 0) {\r\n            state = {};\r\n        }\r\n        if (shapeAssertionError) {\r\n            throw shapeAssertionError;\r\n        }\r\n        if (true) {\r\n            var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\r\n            if (warningMessage) {\r\n                warning(warningMessage);\r\n            }\r\n        }\r\n        var hasChanged = false;\r\n        var nextState = {};\r\n        for (var _i = 0; _i < finalReducerKeys.length; _i++) {\r\n            var _key = finalReducerKeys[_i];\r\n            var reducer = finalReducers[_key];\r\n            var previousStateForKey = state[_key];\r\n            var nextStateForKey = reducer(previousStateForKey, action);\r\n            if (typeof nextStateForKey === 'undefined') {\r\n                var actionType = action && action.type;\r\n                throw new Error( false ? undefined : \"When called with an action of type \" + (actionType ? \"\\\"\" + String(actionType) + \"\\\"\" : '(unknown type)') + \", the slice reducer for key \\\"\" + _key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\r\n            }\r\n            nextState[_key] = nextStateForKey;\r\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\r\n        }\r\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\r\n        return hasChanged ? nextState : state;\r\n    };\r\n}\r\nexports.combineReducers = combineReducers;\r\nfunction bindActionCreator(actionCreator, dispatch) {\r\n    return function () {\r\n        return dispatch(actionCreator.apply(this, arguments));\r\n    };\r\n}\r\n/**\r\n * Turns an object whose values are action creators, into an object with the\r\n * same keys, but with every function wrapped into a `dispatch` call so they\r\n * may be invoked directly. This is just a convenience method, as you can call\r\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\r\n *\r\n * For convenience, you can also pass an action creator as the first argument,\r\n * and get a dispatch wrapped function in return.\r\n *\r\n * @param {Function|Object} actionCreators An object whose values are action\r\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\r\n * syntax. You may also pass a single function.\r\n *\r\n * @param {Function} dispatch The `dispatch` function available on your Redux\r\n * store.\r\n *\r\n * @returns {Function|Object} The object mimicking the original object, but with\r\n * every action creator wrapped into the `dispatch` call. If you passed a\r\n * function as `actionCreators`, the return value will also be a single\r\n * function.\r\n */\r\nfunction bindActionCreators(actionCreators, dispatch) {\r\n    if (typeof actionCreators === 'function') {\r\n        return bindActionCreator(actionCreators, dispatch);\r\n    }\r\n    if (typeof actionCreators !== 'object' || actionCreators === null) {\r\n        throw new Error( false ? undefined : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\r\n    }\r\n    var boundActionCreators = {};\r\n    for (var key in actionCreators) {\r\n        var actionCreator = actionCreators[key];\r\n        if (typeof actionCreator === 'function') {\r\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\r\n        }\r\n    }\r\n    return boundActionCreators;\r\n}\r\nexports.bindActionCreators = bindActionCreators;\r\n/**\r\n * Composes single-argument functions from right to left. The rightmost\r\n * function can take multiple arguments as it provides the signature for\r\n * the resulting composite function.\r\n *\r\n * @param {...Function} funcs The functions to compose.\r\n * @returns {Function} A function obtained by composing the argument functions\r\n * from right to left. For example, compose(f, g, h) is identical to doing\r\n * (...args) => f(g(h(...args))).\r\n */\r\nfunction compose() {\r\n    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        funcs[_key] = arguments[_key];\r\n    }\r\n    if (funcs.length === 0) {\r\n        return function (arg) {\r\n            return arg;\r\n        };\r\n    }\r\n    if (funcs.length === 1) {\r\n        return funcs[0];\r\n    }\r\n    return funcs.reduce(function (a, b) {\r\n        return function () {\r\n            return a(b.apply(void 0, arguments));\r\n        };\r\n    });\r\n}\r\nexports.compose = compose;\r\n/**\r\n * Creates a store enhancer that applies middleware to the dispatch method\r\n * of the Redux store. This is handy for a variety of tasks, such as expressing\r\n * asynchronous actions in a concise manner, or logging every action payload.\r\n *\r\n * See `redux-thunk` package as an example of the Redux middleware.\r\n *\r\n * Because middleware is potentially asynchronous, this should be the first\r\n * store enhancer in the composition chain.\r\n *\r\n * Note that each middleware will be given the `dispatch` and `getState` functions\r\n * as named arguments.\r\n *\r\n * @param {...Function} middlewares The middleware chain to be applied.\r\n * @returns {Function} A store enhancer applying the middleware.\r\n */\r\nfunction applyMiddleware() {\r\n    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        middlewares[_key] = arguments[_key];\r\n    }\r\n    return function (createStore) {\r\n        return function () {\r\n            var store = createStore.apply(void 0, arguments);\r\n            var _dispatch = function dispatch() {\r\n                throw new Error( false ? undefined : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\r\n            };\r\n            var middlewareAPI = {\r\n                getState: store.getState,\r\n                dispatch: function dispatch() {\r\n                    return _dispatch.apply(void 0, arguments);\r\n                }\r\n            };\r\n            var chain = middlewares.map(function (middleware) {\r\n                return middleware(middlewareAPI);\r\n            });\r\n            _dispatch = compose.apply(void 0, chain)(store.dispatch);\r\n            return (0, objectSpread2_1.default)((0, objectSpread2_1.default)({}, store), {}, {\r\n                dispatch: _dispatch\r\n            });\r\n        };\r\n    };\r\n}\r\nexports.applyMiddleware = applyMiddleware;\r\n\n\n//# sourceURL=webpack:///./node_modules/redux/es/redux.js?");

/***/ }),

/***/ "./src/App.tsx":
/*!*********************!*\
  !*** ./src/App.tsx ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.App = void 0;\r\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\r\nconst react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\nconst root_1 = __webpack_require__(/*! react-hot-loader/root */ \"./node_modules/react-hot-loader/root.js\");\r\nconst Layout_1 = __webpack_require__(/*! ./shared/Layout */ \"./src/shared/Layout/index.ts\");\r\n__webpack_require__(/*! ./main.global.css */ \"./src/main.global.css\");\r\nconst Header_1 = __webpack_require__(/*! ./shared/Header */ \"./src/shared/Header/index.ts\");\r\nconst react_redux_1 = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\r\n// import { store } from './store'\r\nconst react_router_dom_1 = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/dist/index.js\");\r\nconst NotFound_1 = __webpack_require__(/*! ./shared/NotFound */ \"./src/shared/NotFound/index.ts\");\r\nconst Content_1 = __webpack_require__(/*! ./shared/Content */ \"./src/shared/Content/index.ts\");\r\nconst Stats_1 = __webpack_require__(/*! ./shared/Stats */ \"./src/shared/Stats/index.ts\");\r\nconst TimerContainer_1 = __webpack_require__(/*! ./shared/TimerContainer */ \"./src/shared/TimerContainer/index.ts\");\r\nconst actions_1 = __webpack_require__(/*! ./store/actions */ \"./src/store/actions.ts\");\r\nconst react_2 = __webpack_require__(/*! redux-persist/integration/react */ \"./node_modules/redux-persist/es/integration/react.js\");\r\nconst store_1 = __webpack_require__(/*! ./store */ \"./src/store.ts\");\r\nfunction AppComponent() {\r\n    const [mouted, setMounted] = (0, react_1.useState)(false);\r\n    (0, react_1.useEffect)(() => {\r\n        setMounted(true);\r\n        store_1.store.dispatch((0, actions_1.statAdd)({ date: new Date(), workTime: 0, pauseTime: 0, tomato: 0, stops: 0 }));\r\n    }, []);\r\n    return ((0, jsx_runtime_1.jsx)(react_redux_1.Provider, Object.assign({ store: store_1.store }, { children: (0, jsx_runtime_1.jsx)(react_2.PersistGate, Object.assign({ loading: null, persistor: store_1.persistor }, { children: (0, jsx_runtime_1.jsx)(TimerContainer_1.TimerContainer, { children: (0, jsx_runtime_1.jsxs)(react_router_dom_1.Routes, { children: [(0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { path: '*', element: (0, jsx_runtime_1.jsx)(NotFound_1.NotFound, {}) }), (0, jsx_runtime_1.jsxs)(react_router_dom_1.Route, Object.assign({ path: '/', element: (0, jsx_runtime_1.jsx)(Layout_1.Layout, { children: (0, jsx_runtime_1.jsx)(Header_1.Header, {}) }) }, { children: [(0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { path: '/', element: (0, jsx_runtime_1.jsx)(Content_1.Content, {}) }), (0, jsx_runtime_1.jsx)(react_router_dom_1.Route, { path: '/stats', element: (0, jsx_runtime_1.jsx)(Stats_1.Stats, {}) })] }))] }) }) })) })));\r\n}\r\nexports.App = (0, root_1.hot)(() => (0, jsx_runtime_1.jsx)(AppComponent, {}));\r\n\n\n//# sourceURL=webpack:///./src/App.tsx?");

/***/ }),

/***/ "./src/store.ts":
/*!**********************!*\
  !*** ./src/store.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.persistor = exports.store = exports.initialState = void 0;\r\nconst redux_1 = __webpack_require__(/*! redux */ \"./node_modules/redux/es/redux.js\");\r\nconst redux_devtools_extension_1 = __webpack_require__(/*! redux-devtools-extension */ \"./node_modules/redux-devtools-extension/index.js\");\r\nconst redux_thunk_1 = __importDefault(__webpack_require__(/*! redux-thunk */ \"./node_modules/redux-thunk/es/index.js\"));\r\nconst reducer_1 = __webpack_require__(/*! ./store/reducer */ \"./src/store/reducer.ts\");\r\nconst generateRandomIndex_1 = __webpack_require__(/*! ./util/react/generateRandomIndex */ \"./src/util/react/generateRandomIndex.tsx\");\r\nconst redux_persist_1 = __webpack_require__(/*! redux-persist */ \"./node_modules/redux-persist/es/index.js\");\r\nconst storage_1 = __importDefault(__webpack_require__(/*! redux-persist/lib/storage */ \"./node_modules/redux-persist/lib/storage/index.js\"));\r\nexports.initialState = {\r\n    stats: [\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date(),\r\n            tomato: 0,\r\n            workTime: 0,\r\n            pauseTime: 0,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.30.23'),\r\n            tomato: 2,\r\n            workTime: 2500,\r\n            pauseTime: 124,\r\n            stops: 3,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.29.23'),\r\n            tomato: 3,\r\n            workTime: 2660,\r\n            pauseTime: 233,\r\n            stops: 4,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.28.23'),\r\n            tomato: 3,\r\n            workTime: 2660,\r\n            pauseTime: 233,\r\n            stops: 4,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.27.23'),\r\n            tomato: 2,\r\n            workTime: 2500,\r\n            pauseTime: 124,\r\n            stops: 3,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.26.23'),\r\n            tomato: 4,\r\n            workTime: 1500,\r\n            pauseTime: 0,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.25.23'),\r\n            tomato: 4,\r\n            workTime: 4500,\r\n            pauseTime: 4500,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.24.23'),\r\n            tomato: 3,\r\n            workTime: 3660,\r\n            pauseTime: 1383,\r\n            stops: 4,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.23.23'),\r\n            tomato: 3,\r\n            workTime: 2660,\r\n            pauseTime: 2033,\r\n            stops: 4,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.22.23'),\r\n            tomato: 2,\r\n            workTime: 5500,\r\n            pauseTime: 1024,\r\n            stops: 3,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.21.23'),\r\n            tomato: 4,\r\n            workTime: 2500,\r\n            pauseTime: 0,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: () => new Date('5.20.23'),\r\n            tomato: 2,\r\n            workTime: 2500,\r\n            pauseTime: 124,\r\n            stops: 3,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.19.23'),\r\n            tomato: 4,\r\n            workTime: 1500,\r\n            pauseTime: 0,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.18.23'),\r\n            tomato: 3,\r\n            workTime: 2660,\r\n            pauseTime: 233,\r\n            stops: 4,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.17.23'),\r\n            tomato: 4,\r\n            workTime: 1500,\r\n            pauseTime: 0,\r\n            stops: 0,\r\n        },\r\n        {\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            date: new Date('5.16.23'),\r\n            tomato: 2,\r\n            workTime: 2500,\r\n            pauseTime: 124,\r\n            stops: 3,\r\n        },\r\n    ],\r\n    tasks: [\r\n        {\r\n            title: 'Сверстать сайт',\r\n            tomato: 1,\r\n            complete: 0,\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            done: false,\r\n        },\r\n        {\r\n            title: 'Aдаптив',\r\n            complete: 0,\r\n            tomato: 1,\r\n            id: (0, generateRandomIndex_1.generateRandomString)(),\r\n            done: false,\r\n        },\r\n    ],\r\n    timerModel: {\r\n        options: {\r\n            workTime: 20,\r\n            pauseTime: 10,\r\n        },\r\n        mode: 'stop',\r\n        part: 'work',\r\n        time: 20,\r\n        event: null\r\n    },\r\n};\r\nconst persistConfig = {\r\n    key: 'root',\r\n    storage: storage_1.default,\r\n};\r\n// export const store = createStore(\r\n//     persistReducer(persistConfig, rootReducer),\r\n//     composeWithDevTools(applyMiddleware(thunk))\r\n// )\r\nconst persistedReducer = (0, redux_persist_1.persistReducer)(persistConfig, reducer_1.rootReducer);\r\nexports.store = (0, redux_1.createStore)(persistedReducer, (0, redux_devtools_extension_1.composeWithDevTools)((0, redux_1.applyMiddleware)(redux_thunk_1.default)));\r\nexports.persistor = (0, redux_persist_1.persistStore)(exports.store);\r\n\n\n//# sourceURL=webpack:///./src/store.ts?");

/***/ }),

/***/ "./src/store/reducer.ts":
/*!******************************!*\
  !*** ./src/store/reducer.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.rootReducer = void 0;\r\nconst store_1 = __webpack_require__(/*! ../store */ \"./src/store.ts\");\r\nconst actions_1 = __webpack_require__(/*! ./actions */ \"./src/store/actions.ts\");\r\nconst generateRandomIndex_1 = __webpack_require__(/*! ../util/react/generateRandomIndex */ \"./src/util/react/generateRandomIndex.tsx\");\r\nconst rootReducer = (state = store_1.initialState, action) => {\r\n    switch (action.type) {\r\n        case actions_1.SET_TIMER_EVENT: {\r\n            return Object.assign(Object.assign({}, state), { timerModel: Object.assign(Object.assign({}, state.timerModel), { event: action.event }) });\r\n        }\r\n        case actions_1.SET_TIMER_PART: {\r\n            return Object.assign(Object.assign({}, state), { timerModel: Object.assign(Object.assign({}, state.timerModel), { part: action.part }) });\r\n        }\r\n        case actions_1.SET_TIME: {\r\n            return Object.assign(Object.assign({}, state), { timerModel: Object.assign(Object.assign({}, state.timerModel), { time: action.time }) });\r\n        }\r\n        case actions_1.SET_TIMER_MODE: {\r\n            return Object.assign(Object.assign({}, state), { timerModel: Object.assign(Object.assign({}, state.timerModel), { mode: action.mode }) });\r\n        }\r\n        case actions_1.STAT_ADD: {\r\n            if (state.stats.find((el) => {\r\n                return el.date.getDate() === new Date().getDate();\r\n            })) {\r\n                return Object.assign(Object.assign({}, state), { stats: state.stats.map((el) => {\r\n                        if (el.date.getDate() === action.stat.date.getDate()) {\r\n                            return Object.assign(Object.assign({}, el), { stops: el.stops + action.stat.stops, pauseTime: el.pauseTime + action.stat.pauseTime, workTime: el.workTime + action.stat.workTime, tomato: el.tomato + action.stat.tomato });\r\n                        }\r\n                        else {\r\n                            return el;\r\n                        }\r\n                    }) });\r\n            }\r\n            else {\r\n                return Object.assign(Object.assign({}, state), { stats: state.stats.concat(Object.assign(Object.assign({}, action.stat), { id: (0, generateRandomIndex_1.generateRandomString)() })) });\r\n            }\r\n        }\r\n        case actions_1.SET_TASKS: {\r\n            return Object.assign(Object.assign({}, state), { tasks: action.tasks });\r\n        }\r\n        case actions_1.INC_TOMATO:\r\n            return Object.assign(Object.assign({}, state), { tasks: state.tasks.map((task) => {\r\n                    if (task.id === action.id)\r\n                        return Object.assign(Object.assign({}, task), { tomato: task.tomato + 1 });\r\n                    return task;\r\n                }) });\r\n        case actions_1.DEC_TOMATO:\r\n            if (state.tasks.find((el) => el.id === action.id).tomato > 1) {\r\n                return Object.assign(Object.assign({}, state), { tasks: state.tasks.map((task) => {\r\n                        if (task.id === action.id) {\r\n                            if (task.tomato === 1) {\r\n                                return Object.assign(Object.assign({}, task), { tomato: task.tomato - 1, complete: task.complete + 1, done: true });\r\n                            }\r\n                            return Object.assign(Object.assign({}, task), { tomato: task.tomato - 1, complete: task.complete + 1 });\r\n                        }\r\n                        return task;\r\n                    }) });\r\n            }\r\n            else {\r\n                return Object.assign(Object.assign({}, state), { tasks: state.tasks.filter((task) => {\r\n                        return task.id !== action.id;\r\n                    }) });\r\n            }\r\n        case actions_1.EDIT_TASK:\r\n            return Object.assign(Object.assign({}, state), { tasks: state.tasks.map((task) => {\r\n                    if (task.id === action.id)\r\n                        return Object.assign(Object.assign({}, task), { title: action.title });\r\n                    return task;\r\n                }) });\r\n        case actions_1.ADD_TASK:\r\n            return Object.assign(Object.assign({}, state), { tasks: state.tasks.concat(action.task) });\r\n        case actions_1.DELETE_TASK:\r\n            return Object.assign(Object.assign({}, state), { tasks: state.tasks.filter((task) => task.id !== action.id) });\r\n    }\r\n    return Object.assign({}, state);\r\n};\r\nexports.rootReducer = rootReducer;\r\n\n\n//# sourceURL=webpack:///./src/store/reducer.ts?");

/***/ })

})